#!/usr/bin/env python3
"""
DEB Package Dependency Analyzer & Downloader
Scans .deb files in current directory, analyzes dependencies, 
and downloads missing dependencies using apt download (without installing).
this script is generated by claude code 2026.1.31
"""

import os
import re
import subprocess
from pathlib import Path
from collections import defaultdict, deque

def get_deb_info(deb_file):
    """Extract package name, version, and dependencies from a .deb file."""
    try:
        result = subprocess.run(
            ['dpkg-deb', '-f', deb_file],
            capture_output=True,
            text=True,
            check=True
        )
        
        info = {}
        for line in result.stdout.split('\n'):
            if line.startswith('Package:'):
                info['package'] = line.split(':', 1)[1].strip()
            elif line.startswith('Version:'):
                info['version'] = line.split(':', 1)[1].strip()
            elif line.startswith('Depends:'):
                deps_str = line.split(':', 1)[1].strip()
                info['depends'] = parse_dependencies(deps_str)
        
        if 'depends' not in info:
            info['depends'] = []
        
        return info
    except subprocess.CalledProcessError as e:
        print(f"Error reading {deb_file}: {e}")
        return None

def parse_dependencies(deps_str):
    """Parse dependency string into list of package names."""
    if not deps_str:
        return []
    
    # Split by comma, handle alternatives (|), and version constraints
    deps = []
    for dep in deps_str.split(','):
        dep = dep.strip()
        # Take first alternative if there are multiple (separated by |)
        if '|' in dep:
            dep = dep.split('|')[0].strip()
        # Remove version constraints (>=, <=, =, etc.)
        dep = re.split(r'\s*\(', dep)[0].strip()
        if dep:
            deps.append(dep)
    
    return deps

def find_real_package_name(package_name):
    """
    Find the real package name using apt-cache search.
    Handles virtual packages and versioned package names.
    """
    # First try exact match with apt-cache show
    try:
        result = subprocess.run(
            ['apt-cache', 'show', package_name],
            capture_output=True,
            text=True
        )
        if result.returncode == 0:
            return package_name
    except:
        pass
    
    # If exact match fails, search for similar packages
    try:
        # Remove version suffix patterns like t64, api-, dbdabi- etc
        base_name = re.sub(r'(t64|api-[\d.]+|dbdabi-\d+)$', '', package_name)
        
        # Search for packages
        result = subprocess.run(
            ['apt-cache', 'search', '--names-only', f'^{base_name}'],
            capture_output=True,
            text=True
        )
        
        if result.returncode == 0 and result.stdout.strip():
            lines = result.stdout.strip().split('\n')
            if lines:
                # Return the first matching package name
                first_match = lines[0].split(' - ')[0].strip()
                return first_match
        
        # If no exact base match, try broader search
        result = subprocess.run(
            ['apt-cache', 'search', '--names-only', base_name],
            capture_output=True,
            text=True
        )
        
        if result.returncode == 0 and result.stdout.strip():
            lines = result.stdout.strip().split('\n')
            if lines:
                first_match = lines[0].split(' - ')[0].strip()
                return first_match
                
    except:
        pass
    
    return None

def compare_versions(ver1, ver2):
    """
    Compare two Debian package versions using dpkg.
    Returns: 1 if ver1 > ver2, -1 if ver1 < ver2, 0 if equal
    """
    try:
        result = subprocess.run(
            ['dpkg', '--compare-versions', ver1, 'gt', ver2],
            capture_output=True
        )
        if result.returncode == 0:
            return 1
        
        result = subprocess.run(
            ['dpkg', '--compare-versions', ver1, 'lt', ver2],
            capture_output=True
        )
        if result.returncode == 0:
            return -1
        
        return 0
    except:
        # Fallback to string comparison if dpkg fails
        if ver1 > ver2:
            return 1
        elif ver1 < ver2:
            return -1
        return 0

def find_duplicate_packages(package_info):
    """
    Find duplicate packages (same package name, different versions).
    Returns dict of package_name -> list of (version, filepath) tuples
    """
    packages_by_name = defaultdict(list)
    
    for filepath, info in package_info.items():
        pkg_name = info['package']
        pkg_version = info['version']
        packages_by_name[pkg_name].append((pkg_version, filepath))
    
    # Filter to only packages with multiple versions
    duplicates = {}
    for pkg_name, versions in packages_by_name.items():
        if len(versions) > 1:
            # Sort by version using dpkg --compare-versions (newest first)
            def version_key(item):
                # Return a comparable key - we'll use a custom sort
                return item[0]
            
            # Sort using dpkg comparison
            sorted_versions = sorted(versions, 
                                    key=lambda x: x[0],
                                    reverse=False)  # Start with oldest first
            
            # Now properly sort using dpkg --compare-versions
            for i in range(len(sorted_versions)):
                for j in range(i + 1, len(sorted_versions)):
                    ver1 = sorted_versions[i][0]
                    ver2 = sorted_versions[j][0]
                    
                    # If ver2 > ver1, swap them
                    if compare_versions(ver2, ver1) > 0:
                        sorted_versions[i], sorted_versions[j] = sorted_versions[j], sorted_versions[i]
            
            duplicates[pkg_name] = sorted_versions
    
    return duplicates

def is_package_installed(package_name):
    """Check if a package is installed on the system."""
    try:
        result = subprocess.run(
            ['dpkg', '-s', package_name],
            capture_output=True,
            text=True
        )
        return result.returncode == 0
    except:
        return False
    """Check if a package is installed on the system."""
    try:
        result = subprocess.run(
            ['dpkg', '-s', package_name],
            capture_output=True,
            text=True
        )
        return result.returncode == 0
    except:
        return False

def get_installed_version(package_name):
    """Get version of installed package."""
    try:
        result = subprocess.run(
            ['dpkg-query', '-W', '-f=${Version}', package_name],
            capture_output=True,
            text=True
        )
        if result.returncode == 0:
            return result.stdout.strip()
    except:
        pass
    return None

def topological_sort(deb_packages, package_info):
    """Sort packages by dependency order using topological sort."""
    # Build adjacency list (package -> packages that depend on it)
    graph = defaultdict(list)
    in_degree = defaultdict(int)
    
    # Get all package names available locally
    available_packages = set(package_info.keys())
    
    for pkg in deb_packages:
        pkg_name = package_info[pkg]['package']
        in_degree[pkg_name] = 0
    
    for pkg in deb_packages:
        pkg_name = package_info[pkg]['package']
        deps = package_info[pkg]['depends']
        
        for dep in deps:
            # Only consider dependencies that are in our local .deb files
            if dep in available_packages:
                graph[dep].append(pkg_name)
                in_degree[pkg_name] += 1
    
    # Kahn's algorithm for topological sort
    queue = deque([pkg for pkg in in_degree if in_degree[pkg] == 0])
    sorted_packages = []
    
    while queue:
        pkg = queue.popleft()
        sorted_packages.append(pkg)
        
        for neighbor in graph[pkg]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    # Check for circular dependencies
    if len(sorted_packages) != len(in_degree):
        print("Warning: Circular dependency detected!")
    
    # Map back to .deb filenames
    pkg_to_file = {package_info[pkg]['package']: pkg for pkg in deb_packages}
    return [pkg_to_file[pkg] for pkg in sorted_packages if pkg in pkg_to_file]

def main():
    # Find all .deb files in current directory
    current_dir = Path('.')
    deb_files = list(current_dir.glob('*.deb'))
    
    if not deb_files:
        print("No .deb files found in current directory.")
        return
    
    print(f"Found {len(deb_files)} .deb file(s)\n")
    
    # Extract package information
    package_info = {}
    for deb_file in deb_files:
        info = get_deb_info(str(deb_file))
        if info:
            package_info[str(deb_file)] = info
            print(f"üì¶ {info['package']} ({info['version']})")
    
    print("\n" + "="*60)
    
    # Check for duplicate packages (same package, different versions)
    duplicates = find_duplicate_packages(package_info)
    
    if duplicates:
        print("\n‚ö†Ô∏è  Duplicate Packages Detected (Multiple Versions):")
        print("="*60)
        
        files_to_delete = []
        
        for pkg_name, versions in duplicates.items():
            print(f"\nüì¶ {pkg_name}:")
            newest_version = versions[0][0]
            
            for i, (version, filepath) in enumerate(versions):
                is_newest = (i == 0)
                marker = "  [NEWEST] " if is_newest else "  [OLD]    "
                print(f"{marker}v{version} - {filepath}")
                
                if not is_newest:
                    files_to_delete.append(filepath)
        
        if files_to_delete:
            print("\n" + "="*60)
            print(f"\nFound {len(files_to_delete)} older version(s) that can be removed.")
            response = input("Delete older versions? (y/n): ")
            
            if response.lower() == 'y':
                print("\nüóëÔ∏è  Deleting older versions...\n")
                deleted_count = 0
                
                for filepath in files_to_delete:
                    try:
                        os.remove(filepath)
                        print(f"  ‚úì Deleted: {filepath}")
                        # Remove from package_info to avoid using it later
                        if filepath in package_info:
                            del package_info[filepath]
                        deleted_count += 1
                    except Exception as e:
                        print(f"  ‚úó Failed to delete {filepath}: {e}")
                
                print(f"\n‚úì Deleted {deleted_count} file(s)")
                print("\n" + "="*60)
            else:
                print("\nKeeping all versions.")
                print("="*60)
    
    # Check for missing dependencies
    missing_deps = {}
    all_local_packages = set(info['package'] for info in package_info.values())
    
    for deb_file, info in package_info.items():
        for dep in info['depends']:
            # Check if dependency is not in local .deb files and not installed
            if dep not in all_local_packages and not is_package_installed(dep):
                if dep not in missing_deps:
                    missing_deps[dep] = []
                missing_deps[dep].append(info['package'])
    
    if missing_deps:
        print("\n‚ö†Ô∏è  Missing Dependencies (not found locally or on system):")
        print("="*60)
        for dep, required_by in missing_deps.items():
            version = get_installed_version(dep) or "unknown"
            print(f"  ‚Ä¢ {dep} (version: {version})")
            print(f"    Required by: {', '.join(required_by)}")
        print()
    
    # Sort packages by dependency order
    sorted_debs = topological_sort(list(package_info.keys()), package_info)
    
    print("\nüìã Suggested Installation Order:")
    print("="*60)
    for i, deb_file in enumerate(sorted_debs, 1):
        info = package_info[deb_file]
        print(f"{i}. {info['package']} ({info['version']}) - {deb_file}")
    
    # Download missing dependencies
    downloaded_files = []
    if missing_deps:
        print("\n" + "="*60)
        response = input(f"\nDownload {len(missing_deps)} missing dependencies? (y/n): ")
        
        if response.lower() == 'y':
            print("\nüì• Downloading missing dependencies...\n")
            downloaded = 0
            failed = []
            
            for dep in missing_deps.keys():
                print(f"Downloading {dep}...")
                try:
                    result = subprocess.run(
                        ['apt', 'download', dep],
                        capture_output=True,
                        text=True,
                        check=True
                    )
                    print(f"  ‚úì {dep} downloaded successfully")
                    downloaded += 1
                    # Find the downloaded .deb file
                    # apt download creates files like: packagename_version_arch.deb
                    for file in Path('.').glob(f'{dep}_*.deb'):
                        if file.name not in [Path(f).name for f in sorted_debs]:
                            downloaded_files.append(str(file))
                            break
                except subprocess.CalledProcessError as e:
                    # Try to find the real package name
                    print(f"  ‚ö† Direct download failed, searching for real package name...")
                    real_name = find_real_package_name(dep)
                    
                    if real_name and real_name != dep:
                        print(f"  ‚Üí Found: {real_name}")
                        try:
                            result = subprocess.run(
                                ['apt', 'download', real_name],
                                capture_output=True,
                                text=True,
                                check=True
                            )
                            print(f"  ‚úì {real_name} downloaded successfully")
                            downloaded += 1
                            # Find the downloaded .deb file
                            for file in Path('.').glob(f'{real_name}_*.deb'):
                                if file.name not in [Path(f).name for f in sorted_debs]:
                                    downloaded_files.append(str(file))
                                    break
                        except subprocess.CalledProcessError:
                            print(f"  ‚úó Failed to download {real_name}")
                            failed.append(f"{dep} (tried: {real_name})")
                    else:
                        print(f"  ‚úó Could not find package for {dep}")
                        failed.append(dep)
            
            print(f"\nüìä Download Summary:")
            print(f"  ‚úì Successfully downloaded: {downloaded}")
            if failed:
                print(f"  ‚úó Failed to download: {len(failed)}")
                print(f"    Failed packages:")
                for pkg in failed:
                    print(f"      - {pkg}")
        else:
            print("Download cancelled.")
    
    # Generate installation script including downloaded dependencies
    print("\n" + "="*60)
    all_files_to_install = downloaded_files + sorted_debs  # Dependencies first!
    
    if all_files_to_install:
        response = input(f"\nGenerate installation script for {len(all_files_to_install)} packages? (y/n): ")
        
        if response.lower() == 'y':
            script_content = """#!/bin/bash
# DEB Package Installation Script
# Generated by deb_analyzer.py
# This script installs packages in dependency order

set -e  # Exit on error

echo "=================================="
echo "DEB Package Installation Script"
echo "=================================="
echo ""

# Color codes for output
RED='\\033[0;31m'
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
NC='\\033[0m' # No Color

INSTALLED=0
FAILED=0
TOTAL=""" + str(len(all_files_to_install)) + """

"""
            
            file_index = 1
            
            # Add installation commands for downloaded dependencies FIRST
            if downloaded_files:
                script_content += """
echo "=================================="
echo "Installing Downloaded Dependencies"
echo "=================================="
echo ""
"""
                for deb_file in downloaded_files:
                    script_content += f"""
echo "[{file_index}/{len(all_files_to_install)}] Installing downloaded dependency: {deb_file}..."
if sudo dpkg -i "{deb_file}"; then
    echo -e "${{GREEN}}‚úì {deb_file} installed successfully${{NC}}"
    ((INSTALLED++))
else
    echo -e "${{RED}}‚úó Failed to install {deb_file}${{NC}}"
    ((FAILED++))
    echo -e "${{YELLOW}}Attempting to fix dependencies...${{NC}}"
    sudo apt-get -f install -y
fi
echo ""
"""
                    file_index += 1
            
            # Then add installation commands for original packages
            if sorted_debs:
                script_content += """
echo "=================================="
echo "Installing Original Packages"
echo "=================================="
echo ""
"""
                for deb_file in sorted_debs:
                    info = package_info[deb_file]
                    script_content += f"""
echo "[{file_index}/{len(all_files_to_install)}] Installing {info['package']} ({info['version']})..."
if sudo dpkg -i "{deb_file}"; then
    echo -e "${{GREEN}}‚úì {info['package']} installed successfully${{NC}}"
    ((INSTALLED++))
else
    echo -e "${{RED}}‚úó Failed to install {info['package']}${{NC}}"
    ((FAILED++))
    echo -e "${{YELLOW}}Attempting to fix dependencies...${{NC}}"
    sudo apt-get -f install -y
fi
echo ""
"""
                    file_index += 1
            
            script_content += """
echo "=================================="
echo "Installation Summary"
echo "=================================="
echo -e "Total packages: $TOTAL"
echo -e "${GREEN}Successfully installed: $INSTALLED${NC}"
if [ $FAILED -gt 0 ]; then
    echo -e "${RED}Failed: $FAILED${NC}"
fi
echo ""

if [ $FAILED -eq 0 ]; then
    echo -e "${GREEN}‚úÖ All packages installed successfully!${NC}"
else
    echo -e "${YELLOW}‚ö†Ô∏è  Some packages failed to install. Check the output above.${NC}"
fi
"""
            
            # Write script to file
            script_path = 'pre-install.sh'
            try:
                with open(script_path, 'w') as f:
                    f.write(script_content)
                
                # Make script executable
                os.chmod(script_path, 0o755)
                
                print(f"\n‚úì Installation script generated: {script_path}")
                if downloaded_files:
                    print(f"  - Downloaded dependencies (install first): {len(downloaded_files)}")
                print(f"  - Original packages (install after): {len(sorted_debs)}")
                print(f"\nTo run the script:")
                print(f"  ./pre-install.sh")
                print(f"\nOr with bash:")
                print(f"  bash pre-install.sh")
            except Exception as e:
                print(f"\n‚úó Failed to generate script: {e}")
    
    print("\n" + "="*60)
    print("‚úÖ Dependency analysis complete!")

if __name__ == '__main__':
    main()
